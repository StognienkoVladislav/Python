

import numpy as np

a = np.array([20, 30, 40, 50])
b = np.arange(4)

print(a + b)
print(a - b)
print(a * b)
print(a / b)
print(a ** b)
print(a % b)

#Для этого массивы должны быть одинаковых размеров

c = np.array([[1, 2, 3], [4, 5, 6]])
d = np.array(([1, 2], [3, 4], [5, 6]))
c + d #ValueError

#Операц между массивом и числом
print(a + 1)
print(a ** 3)
print(a < 35)   #Можно произвести фильтрацию


#Множество мат операций для обработки массивов
print(np.cos(a))
print(np.arctan(a))
print(np.sinh(a))


#Унарные операции
a = np.array([[1, 2, 3], [4, 5, 6]])
print(np.sum(a))
print(a.sum())
print(a.min())
print(a.max())

#По умолчанию выполн как если бы использовали список
#при axis можно применить операцию для опред оси
print(a.min(axis = 0))  #Найменьшее число в каждом столбце
print(a.min(axis = 1))  #Найменьш число в каждой строке

#Индексы, срезы, итерации

a = np.arange(10) ** 3
print(a)

print(a[1])
print(a[3:7])
a[3:7] = 8
print(a)
print(a[::-1])

del a[4:6] #ValueError

for i in a:
    print(i ** (1/3))



#У многомерных массивов на каждую ось приходиться 1 индкес
#Индексы передаются в виде последовательности чисел,
#разделенных запятыми(кортежами)

b = np.array([[0, 1, 2, 3],
              [10, 11, 12, 13],
              [20, 21, 22, 23],
              [30, 31, 32, 33],
              [40, 41, 42, 43]])

print(b[2, 3])      #Вторая строка, третий столбец
print(b[(2, 3)])
print(b[2][3])      #Можно и так
print(b[:,2])       #Третий столбец
print(b[:2])        #Первые 2 строки
print(b[1:3, ::])   #Вторая и третья строки
print(b[-1])        #Эквивалентно b[-1,:]


#################################################
a = np.array(([[0, 1, 2], [10, 12, 13]], [[100, 101, 102], [110, 112, 113]]))
print(a.shape)
print(a[1, ...])    #то же, что a[1, :, :] или a[1]
print(c[..., 2])    #то же, что a[:, :, 2]


#################################################
for row in a:
    print(row)

#С помощью атрибута flat можно перебрать массив, как если бы он был одномерным
for el in a.flat:
    print(el)


#форма Shap, определяемая числом элементов вдоль каждой оси
print(a)
print(a.shape)

#Изменение формы массива с помощью различных команд
print(a.ravel())    #Делает массив плоским

a.shape = (6, 2)    #Изменение формы

print(a)

print(a.transpose())        #Транспонирование
print(a.reshape((3 ,4)))    #Изменение формы

print(a.reshape((3, 4), order = 'F'))   #Возвращает аргумент с измененной формой
print(a.resize((2, 6)))                 #Изменяет сам массив

#Если при перестройки один из аргументов задается как -1,
#то он автоматически рассчитывается в соответсвтвии с остальными заданными

print(a.reshape((3, -1)))


#Несколько массивов могут быть обьединены вместе вдоль разных осей
#с помощью функций hstack и vstack
#hstack() Обьединяет массивы по первым осям
#vstack() по последним
a = np.array([[1, 2], [3, 4]])
b = np.array([[5, 6], [7, 8]])

print(np.vstack((a, b)))

print(np.hstack((a, b)))


#Функция column_stack() Обьединяет одномерные массивы в качестве
#столбцов двумерного массива
print(np.column_stack((a, b)))

#аналогично для строк использ row_stack()
print(np.row_stack((a, b)))


#Разбиение массива
#hsplit() мы можем разбить массив вдоль горизонт оси

a = np.arange(12).reshape((2, 6))
print(a)

print(np.hsplit(a, 3))  #разбить на 3 части

print(np.hsplit(a, (3, 4))) #Разрезать a после 3 и 4 столбца

#vsplit() Разбивает массив вдоль вертикальной оси
#array_split() позволяет указать оси, вдоль которых произойдет разбиение

###############################################################################


#####Копии и представления
#Вообще никаких копий
a = np.arange(12)
b = a               #Не будет создано нового обьекта
print(b is a)       #a и b это два имени одного и того же обьекта ndarray

b.shape = (3,4)     #изменит форму a
print(a.shape)

#Представление или поверхностная копия
c = a.view()
print(c is a)

print(c.base is a)  #Это представление данных, принадлежащих a
print(c.flags.owndata)

c.shape = (2, 6)    #Форма a не поменяется
print(a.shape)

c[0, 4] = 1234      #Данные a изменятся
print(a)

#Срез массива это представление
s = a[:, 1:3]
s[:] = 10
print(a)

#####Глубокая копия
#Метод copy() создаст настоящую копию массива и его данных

d = a.copy()        #Создает новый обьект массива с новыми данными
print(d is a)
print(d.base is a)  #d не имеет ничего общего с a
d[0, 0] = 9999
print(a)            #Ничего не изменилось из-за d
